import type { UUID, VideoMetadata, SizedThumbnail, IdentifiedString, PlaylistItem } from "~/common/types";

export type Nullable<T> = T | null;

export function clampNumber(number: number, min: number, max: number, overflow?: boolean) {
	if (overflow) {
		if (number > max) return min;
		if (number < min) return max;
	}
	return Math.min(Math.max(number, min), max);
}

export function sleep(ms: number) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

export function generateTextSubtitle(...strings: (string | undefined)[]) {
	return strings.filter((string) => string !== undefined).join(" â€¢ ");
}

export interface PlaylistData {
	thumbnails: SizedThumbnail[];
	artists?: IdentifiedString[];
	album_type?: string;
	album?: IdentifiedString;
}

export function metadataFromPlaylistItem(item: PlaylistItem, track?: number, playlistData?: PlaylistData): VideoMetadata {
	// The type property is picked directly from YouTube, it is either a playlist or the album type (album, single,...)
	// There are other "albums", but they act more like collections generated by YT itself (or have too many artists to list)
	const isInsidePlaylist = playlistData && (playlistData.album_type === "Playlist" || !playlistData.artists?.length);
	return {
		video_id: item.id,
		title: item.name,
		album: item.album?.name ?? playlistData?.album?.name,
		track,
		cover: findThumbnailForResolution(
			isInsidePlaylist ? item.thumbnails : (playlistData?.thumbnails ?? item.thumbnails),
			THUMBNAIL_RESOLUTIONS.medium
		)?.url,
		// If this is a normal playlist (user-created), the artists field on the data is empty
		// (Instead, we might find some data on the item itself)
		artists: isInsidePlaylist
			? item.artists.length
				? identifiedStringsToRaw(item.artists)
				: item.creators
			: identifiedStringsToRaw(playlistData?.artists ?? item.artists)
	};
}

export function identifiedStringsToRaw(strings: IdentifiedString[]) {
	return strings.map((string) => string.name);
}

export function rawToIdentifiedString(string?: string): IdentifiedString {
	return { name: string ?? "", id: "" };
}

export function syntaxHighlight(json: any = {}) {
	return JSON.stringify(json, null, 2)
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/gm, (match) => {
			let type = "number";
			if (/^"/.test(match)) {
				if (/:$/.test(match)) {
					type = "key";
				} else {
					type = "string";
				}
			} else if (/true|false/.test(match)) {
				type = "boolean";
			} else if (/null/.test(match)) {
				type = "null";
			}
			return `<span class="${type}">${match}</span>`;
		});
}

export function shortenUUID(uuid: UUID, length: number = 6) {
	return uuid.substring(0, length);
}

export function generateUUID() {
	if ("randomUUID" in crypto) return crypto.randomUUID();
	console.warn("Using unsecure UUID generation");
	let time = performance.now();
	return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx-xxxxxx3xx".replace(/[xy]/g, (char) => {
		const random = (time + Math.random() * 16) % 16 | 0;
		time = Math.floor(time / 16);
		return (char === "x" ? random : (random & 0x3) | 0x8).toString(16);
	}) as UUID;
}

export function objectHasAllProperties<T extends Object>(object: T, keys: (keyof T)[]) {
	const keysOfObject = Object.keys(object);
	return !keys.some((key) => !keysOfObject.includes(key as string));
}

type LocalStorageKey = "settings" | "socket-data";

export function readJSONFromLocalStorage<T>(name: LocalStorageKey): T | null {
	try {
		const value = window.localStorage.getItem(name);
		if (value === null) return null;
		return JSON.parse(value) as T;
	} catch {
		return null;
	}
}

export function writeJSONToLocalStorage<T>(name: LocalStorageKey, data: T) {
	window.localStorage.setItem(name, JSON.stringify(data));
}
